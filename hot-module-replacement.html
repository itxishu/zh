<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="">
		<meta name="author" content="">
		<link rel="icon" type="image/png" href="/assets/favicon.png" />
		<link rel="stylesheet" href="css/doc.css" />
		<title>hot module replacement</title>
	</head>
	<body>
		<script src="js/doc.js" charset="utf-8" async></script>
		<div class="container">
			<div class="row">
				<div class="col-md-3 nav">

					<div class="logo">
	<ul class="cube-inner">
		<li class="front"><li class="back"><li class="right"><li class="left"><li class="top"><li class="bottom">
	</ul>
	<ul class="cube">
		<li class="front"><li class="back"><li class="right"><li class="left"><li class="top"><li class="bottom">
		<li class="floor">
	</ul>
</div>
<div class="name">webpack</div>
<div class="tagline">MODULE BUNDLER</div>


					<div class="sidebar">
						<ul><li><a href=".">Home</a></li></ul>
						<ul>
<li>Getting Started<ul>
<li><a href="motivation.html">Motivation</a></li>
<li><a href="what-is-webpack.html">What is webpack?</a></li>
<li><a href="installation.html">Installation</a></li>
<li><a href="usage.html">Usage</a></li>
<li>Require Modules</li>
<li>Vendor Modules</li>
<li><a href="using-loaders.html">Using Loaders</a></li>
<li><a href="using-plugins.html">Using Plugins</a></li>
<li><a href="dev-tools.html">Dev Tools</a></li>
<li><a href="troubleshooting.html">Troubleshooting</a></li>
</ul>
</li>
<li>Tutorials and examples<ul>
<li><a href="http://webpack.github.io/docs/tutorials/getting-started/">Getting started</a></li>
<li><a href="list-of-tutorials.html">List of tutorials</a></li>
<li><a href="examples.html">examples</a></li>
</ul>
</li>
<li>Guides<ul>
<li><a href="commonjs.html">CommonJs</a></li>
<li><a href="amd.html">AMD</a></li>
<li><a href="webpack-for-browserify-users.html">webpack for browserify users</a></li>
<li><a href="code-splitting.html">Code Splitting</a></li>
<li><a href="stylesheets.html">Stylesheets</a></li>
<li><a href="optimization.html">Optimization</a></li>
<li><a href="long-term-caching.html">Long-term Caching</a></li>
<li><a href="how-to-write-a-loader.html">How to write a loader</a></li>
<li><a href="how-to-write-a-plugin.html">How to write a plugin</a></li>
<li><a href="multiple-entry-points.html">Multiple entry points</a></li>
<li><a href="library-and-externals.html">Library and externals</a></li>
<li><a href="shimming-modules.html">Shimming modules</a></li>
<li><a href="testing.html">Testing</a></li>
<li><a href="build-performance.html">Build performance</a></li>
<li><a href="hot-module-replacement-with-webpack.html">Hot Module Replacement with webpack</a></li>
<li><a href="comparison.html">Comparison</a></li>
</ul>
</li>
<li>webpack with<ul>
<li><a href="usage-with-grunt.html">grunt</a></li>
<li><a href="usage-with-gulp.html">gulp</a></li>
<li><a href="usage-with-bower.html">bower</a></li>
<li><a href="usage-with-karma.html">karma</a></li>
</ul>
</li>
<li>Lists<ul>
<li><a href="loader-conventions.html">loader conventions</a></li>
<li><a href="list-of-loaders.html">List of loaders</a></li>
<li><a href="list-of-plugins.html">List of plugins</a></li>
<li><a href="list-of-tutorials.html">List of tutorials</a></li>
<li><a href="list-of-hints.html">List of hints</a></li>
</ul>
</li>
<li>API<ul>
<li><a href="configuration.html">Configuration</a></li>
<li><a href="cli.html">CLI</a></li>
<li><a href="node.js-api.html">Node.js API</a></li>
<li><a href="api-in-modules.html">API in modules</a></li>
<li><a href="loaders.html">Loaders</a></li>
<li><a href="plugins.html">Plugins</a></li>
<li><a href="context.html">Context</a></li>
<li><a href="resolving.html">Resolving</a></li>
<li><a href="hot-module-replacement.html">Hot Module Replacement</a></li>
<li>Dev Tools<ul>
<li><a href="webpack-dev-server.html">webpack-dev-server</a></li>
<li><a href="webpack-dev-middleware.html">webpack-dev-middleware</a></li>
</ul>
</li>
</ul>
</li>
<li>Development<ul>
<li><a href="changelog.html">Changelog</a></li>
<li><a href="roadmap.html">Roadmap</a></li>
<li><a href="ideas.html">Ideas</a></li>
<li>Contributing</li>
</ul>
</li>
</ul>

					</div>
				</div>

				<div class="col-md-9">
					<!--<div class="announcement">
						<div class="announcement-inner">
							<em>2014-07-04</em> Help to improve webpack by filling out <a href="https://docs.google.com/forms/d/101ZcujnVL8l575T6VRl62SfrVj5FZC1IzwMH1258GVc/viewform">this little survey</a>. Thanks!<br>
							<em>2015-03-04</em> You can now comment doc pages (on the bottom of the page). Free feel to add comments about missing/unclear stuff or fix stuff that other people find unclear. You can use the Edit button on the top right corner.
						</div>
					</div>-->

					<div class="pull-right">
						<a href="https://github.com/webpack/docs/wiki/hot-module-replacement/_edit" class="wikieditlink">Edit</a>
					</div>
					<div class="row">
						<div class="col-md-12 page-header">
							<h1 id="wikititle">hot module replacement</h1>
						</div>
					</div>

					<div class="row">
						<div id="wiki" class="col-md-12">
							<div class="contents"><ul><li><a href="#examples">Examples</a></li><li><a href="#api">API</a><ul><li><a href="#accept"><code>accept</code></a></li><li><a href="#decline"><code>decline</code></a></li><li><a href="#dispose-adddisposehandler"><code>dispose/addDisposeHandler</code></a></li><li><a href="#removedisposehandler"><code>removeDisposeHandler</code></a></li></ul></li><li><a href="#management-api">Management API</a><ul><li><a href="#check"><code>check</code></a></li><li><a href="#apply"><code>apply</code></a></li><li><a href="#status"><code>status</code></a></li><li><a href="#status-addstatushandler"><code>status/addStatusHandler</code></a></li><li><a href="#removestatushandler"><code>removeStatusHandler</code></a></li></ul></li><li><a href="#how-to-deal-with">How to deal with …</a></li></ul></li></ul></div><p>“Hot Module Replacement” (HMR) is a feature to inject updated modules into the active runtime.</p>
<blockquote>
<p>It’s like LiveReload for every module.</p>
</blockquote>
<p>HMR is “opt-in”, so you need to put some code at chosen points of your application. The dependencies are handled by the module system.</p>
<p>I. e. you place your hot replacement code in module A. Module A requires module B and B requires C. If module C is updated, and module B cannot handle the update, modules B and C become outdated. Module A can handle the update and new modules B and C are injected.</p>
<h2 id="examples"><a class="anchor" href="#examples">&rarr;</a>Examples</h2>
<h4 id="example-1-hot-replace-request-handler-of-http-server"><a class="anchor" href="#example-1-hot-replace-request-handler-of-http-server">&rarr;</a>Example 1: hot replace request handler of http server</h4>
<pre><code><span class="keyword">var</span> requestHandler = require(<span class="string">"./handler.js"</span>);
<span class="keyword">var</span> server = require(<span class="string">"http"</span>).createServer();
server.on(<span class="string">"request"</span>, requestHandler);
server.listen(<span class="number">8080</span>);

<span class="comment">// check if HMR is enabled</span>
<span class="keyword">if</span>(module.hot) {
    <span class="comment">// accept update of dependency</span>
    module.hot.accept(<span class="string">"./handler.js"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="comment">// replace request handler of server</span>
        server.removeListener(<span class="string">"request"</span>, requestHandler);
        requestHandler = require(<span class="string">"./handler.js"</span>);
        server.on(<span class="string">"request"</span>, requestHandler);
    });
}</code></pre><h4 id="example-2-hot-replace-css"><a class="anchor" href="#example-2-hot-replace-css">&rarr;</a>Example 2: hot replace css</h4>
<pre><code><span class="comment">// addStyleTag(css: string) =&gt; HTMLStyleElement</span>
<span class="keyword">var</span> addStyleTag = require(<span class="string">"./addStyleTag"</span>);

<span class="keyword">var</span> element = addStyleTag(<span class="string">".rule { attr: name }"</span>);
module.exports = <span class="literal">null</span>;

<span class="comment">// check if HMR is enabled</span>
<span class="keyword">if</span>(module.hot) {

    <span class="comment">// accept itself</span>
    module.hot.accept();

    <span class="comment">// removeStyleTag(element: HTMLStyleElement) =&gt; void</span>
    <span class="keyword">var</span> removeStyleTag = require(<span class="string">"./removeStyleTag"</span>);

    <span class="comment">// dispose handler</span>
    module.hot.dispose(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="comment">// revoke the side effect</span>
        removeStyleTag(element);
    });
}</code></pre><h4 id="example-3-hot-module-replace-with-require-context"><a class="anchor" href="#example-3-hot-module-replace-with-require-context">&rarr;</a>Example 3: Hot module replace with require.context</h4>
<pre><code><span class="keyword">var</span> context = require.context(<span class="string">"./filesToLoad"</span>, <span class="literal">false</span>, <span class="regexp">/\.js$/</span>); <span class="comment">//filesToLoad is a directory with .js files</span>
<span class="keyword">var</span> modules = {};
context.keys().forEach(<span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
  <span class="keyword">var</span> module = context(key);
  modules[key] = module;
  customReloadLogic(key, module, <span class="literal">false</span>);
})

<span class="keyword">if</span> (module.hot) {
  module.hot.accept(context.id, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//You can't use context here. You _need_ to call require.context again to</span>
    <span class="comment">//get the new version. Otherwise you might get errors about using disposed</span>
    <span class="comment">//modules</span>
    <span class="keyword">var</span> reloadedContext = require.context(<span class="string">"./filesToLoad"</span>, <span class="literal">false</span>, <span class="regexp">/\.js$/</span>);
    <span class="comment">//To find out what module was changed you just compare the result of the</span>
    <span class="comment">//require call with the version stored in the modules hash using strict</span>
    <span class="comment">//equality. Equal means it is unchanged.</span>
    <span class="keyword">var</span> changedModules = reloadedContext.keys()
      .map(<span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
        <span class="keyword">return</span> [key, reloadedContext(key)];
      })
      .filter(<span class="function"><span class="keyword">function</span> <span class="params">(reloadedModule)</span> {</span>
        <span class="keyword">return</span> modules[reloadedModule[<span class="number">0</span>]] !== reloadedModule[<span class="number">1</span>];
      });
    changedModules.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(module)</span> {</span>
      modules[module[<span class="number">0</span>]] = module[<span class="number">1</span>];
      customReloadLogic(module[<span class="number">0</span>], module[<span class="number">1</span>], <span class="literal">true</span>);
    });
  });
}

<span class="function"><span class="keyword">function</span> <span class="title">customReloadLogic</span><span class="params">(name, module, isReload)</span> {</span>
  console.log(<span class="string">"module "</span> + name + (isReload ? <span class="string">" re"</span> : <span class="string">" "</span>) + <span class="string">"loaded"</span>);
}</code></pre><p>(see <a href="https://github.com/jauco/webpack-hot-module-reload-with-context-example">https://github.com/jauco/webpack-hot-module-reload-with-context-example</a> for a full working version)</p>
<h2 id="api"><a class="anchor" href="#api">&rarr;</a>API</h2>
<p>If HMR is enabled for a module <code>module.hot</code> is an object containing these properties:</p>
<h3 id="accept"><a class="anchor" href="#accept">&rarr;</a><code>accept</code></h3>
<pre><code>accept(dependencies: string[], callback: (updatedDependencies) =&gt; <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>
accept(dependency: string, callback: () =&gt; <span class="keyword">void</span>) =&gt; <span class="keyword">void</span></code></pre><p>Accept code updates for the specified dependencies. The callback is called when dependencies were replaced.</p>
<pre><code>accept([errHandler]) =&gt; <span class="keyword">void</span></code></pre><p>Accept code updates for this module without notification of parents. This should only be used if the module doesn’t export anything. The <code>errHandler</code> can be used to handle errors that occur while loading the updated module.</p>
<h3 id="decline"><a class="anchor" href="#decline">&rarr;</a><code>decline</code></h3>
<pre><code>decline(dependencies: string[]) =&gt; <span class="keyword">void</span>
decline(dependency: string) =&gt; <span class="keyword">void</span></code></pre><p>Do not accept updates for the specified dependencies. If any dependencies is updated, the code update fails with code <code><span class="string">"decline"</span></code>.</p>
<pre><code>decline() =&gt; <span class="keyword">void</span></code></pre><p>Flag the current module as not update-able. If updated the update code would fail with code <code><span class="string">"decline"</span></code>.</p>
<h3 id="dispose-adddisposehandler"><a class="anchor" href="#dispose-adddisposehandler">&rarr;</a><code>dispose/addDisposeHandler</code></h3>
<pre><code>dispose(callback: (data: object) =&gt; <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>
addDisposeHandler(callback: (data: object) =&gt; <span class="keyword">void</span>) =&gt; <span class="keyword">void</span></code></pre><p>Add a one time handler, which is executed when the current module code is replaced. Here you should destroy/remove any persistent resource you have claimed/created. If you want to transfer state to the new module, add it to <code>data</code> object. The <code>data</code> will be available at <code>module.hot.data</code> on the new module.</p>
<h3 id="removedisposehandler"><a class="anchor" href="#removedisposehandler">&rarr;</a><code>removeDisposeHandler</code></h3>
<pre><code>removeDisposeHandler(callback: (data: object) =&gt; <span class="keyword">void</span>) =&gt; <span class="keyword">void</span></code></pre><p>Remove a handler.</p>
<p>This can useful to add a temporary dispose handler. You could i. e. replace code while in the middle of a multi-step async function.</p>
<h2 id="management-api"><a class="anchor" href="#management-api">&rarr;</a>Management API</h2>
<p>Also on the <code>module.hot</code> object.</p>
<h3 id="check"><a class="anchor" href="#check">&rarr;</a><code>check</code></h3>
<pre><code>check([autoApply], callback: (err: Error, outdatedModules: Module[]) =&gt; <span class="keyword">void</span></code></pre><p>Throws an exceptions if <code>status()</code> is not <code>idle</code>.</p>
<p>Check all currently loaded modules for updates and apply updates if found.</p>
<p>If no update was found, the callback is called with <code><span class="literal">null</span></code>.</p>
<p>If <code>autoApply</code> is truthy the callback will be called with all modules that were disposed. <code>apply()</code> is automatically called with <code>autoApply</code> as <code>options</code> parameter.</p>
<p>If <code>autoApply</code> is not set the callback will be called with all modules that will be disposed on <code>apply()</code>.</p>
<h3 id="apply"><a class="anchor" href="#apply">&rarr;</a><code>apply</code></h3>
<pre><code>apply([options], callback: (err: Error, outdatedModules: Module[]) =&gt; <span class="keyword">void</span></code></pre><p>If <code>status() != <span class="string">"ready"</span></code> it throws an error.</p>
<p>Continue the update process.</p>
<p><code>options</code> can be an object containing these options:</p>
<ul>
<li><code>ignoreUnaccepted</code>: If true the update process continues even if some modules are not accepted (and would bubble to the entry point).</li>
</ul>
<h3 id="status"><a class="anchor" href="#status">&rarr;</a><code>status</code></h3>
<pre><code>status() =&gt; string</code></pre><p>Return one of <code>idle</code>, <code>check</code>, <code>watch</code>, <code>watch-delay</code>, <code>prepare</code>, <code>ready</code>, <code>dispose</code>, <code>apply</code>, <code>abort</code> or <code>fail</code>.</p>
<p><code>idle</code></p>
<p>The HMR is waiting for your call the <code>check()</code>. When you call it the status will change to <code>check</code>.</p>
<p><code>check</code></p>
<p>The HMR is checking for updates. If it doesn’t find updates it will change back to <code>idle</code>.</p>
<p>If updates were found it will go through the steps <code>prepare</code>, <code>dispose</code> and <code>apply</code>. Than back to <code>idle</code>.</p>
<p><code>watch</code></p>
<p>The HMR is in watch mode and will automatically be notified about changes. After the first change it will change to <code>watch-delay</code> and wait for a specified time to start the update process. Any change will reset the timeout, to accumulate more changes. When the update process is started it will go through the steps <code>prepare</code>, <code>dispose</code> and <code>apply</code>. Than back to <code>watch</code> or <code>watch-delay</code> if changes were detected while updating.</p>
<p><code>prepare</code></p>
<p>The HMR is prepare stuff for the update. This may means that it’s downloading something.</p>
<p><code>ready</code></p>
<p>An update is available and prepared. Call <code>apply()</code> to continue.</p>
<p><code>dispose</code></p>
<p>The HMR is calling the dispose handlers of modules that will be replaced.</p>
<p><code>apply</code></p>
<p>The HMR is calling the accept handlers of the parents of replaced modules, than it requires the self accepted modules.</p>
<p><code>abort</code></p>
<p>A update cannot apply, but the system is still in a (old) consistent state.</p>
<p><code>fail</code></p>
<p>A update has thrown an exception in the middle of the process, and the system is (maybe) in a inconsistent state. The system should be restarted.</p>
<h3 id="status-addstatushandler"><a class="anchor" href="#status-addstatushandler">&rarr;</a><code>status/addStatusHandler</code></h3>
<pre><code>status(callback: (status: string) =&gt; <span class="keyword">void</span>) =&gt; <span class="keyword">void</span>
addStatusHandler(callback: (status: string) =&gt; <span class="keyword">void</span>) =&gt; <span class="keyword">void</span></code></pre><p>Register a callback on status change.</p>
<h3 id="removestatushandler"><a class="anchor" href="#removestatushandler">&rarr;</a><code>removeStatusHandler</code></h3>
<pre><code>removeStatusHandler(callback: (status: string) =&gt; <span class="keyword">void</span>) =&gt; <span class="keyword">void</span></code></pre><p>Remove a registered status change handler.</p>
<h2 id="how-to-deal-with"><a class="anchor" href="#how-to-deal-with">&rarr;</a>How to deal with …</h2>
<h4 id="a-module-without-side-effects"><a class="anchor" href="#a-module-without-side-effects">&rarr;</a>… a module without side effects (the standard case)</h4>
<p>Nothing to do in the module. Any parent can accept it.</p>
<h4 id="a-module-with-side-effects"><a class="anchor" href="#a-module-with-side-effects">&rarr;</a>… a module with side effects</h4>
<p>The module needs a dispose handler, then any parent can accept it.</p>
<h4 id="a-module-with-only-side-effects-and-no-exports"><a class="anchor" href="#a-module-with-only-side-effects-and-no-exports">&rarr;</a>… a module with only side effects and no exports</h4>
<p>The module needs a dispose handler and can accept itself. No action is required in the parent.</p>
<p>If the module’s code is not in your hand, the parent can accept the module with some custom dispose logic.</p>
<h4 id="the-application-entry-module"><a class="anchor" href="#the-application-entry-module">&rarr;</a>… the application entry module</h4>
<p>As it doesn’t export it can accept itself. A dispose handler can pass the application state on replacement.</p>
<h4 id="external-module-with-not-handleable-side-effects"><a class="anchor" href="#external-module-with-not-handleable-side-effects">&rarr;</a>… external module with not handleable side effects</h4>
<p>In the nearest parent you decline the dependency. This makes your application throw on update. But as it’s an external module, an update is very rare.</p>

						</div>
					</div>

					<div class="row">
						<div class="col-md-12">
							<div class="pull-right">
								<a href="https://github.com/webpack/docs/wiki/hot-module-replacement/_edit" class="wikieditlink">Edit this page</a>
							</div>
						</div>
					</div>

					<div class="row">
						<div class="col-md-12">
							<div id="disqus_thread"></div>
						</div>
					</div>
				</div>

			</div>
		</div>
		<a href="https://github.com/webpack/webpack"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub"></a>
	</body>
</html>